
	li	$t1, 0		# initialize i
loop_i:
	beq	$t1, $s2, return_false	
	lb	$t2, 0($s3)		# chosen[i]
	bnez	$t2, loop_back_to_i
	
	get_max_x_of_piece($s4, $t1)	# get_max_x_of_piece(pieces[i])
	move	$t3, $v0		#  max_x_of_piece

	#  for offset in range(6 - max_x_of_piece):
	li	$t5, 6
	sub	$t3, $t5, $t3	 	# range(6 - max_x_of_piece)
	li	$t5, 0			# offset
	
loop_offset:
	beq	$t5, $t3, loop_back_to_offset
	# nextGrid, success = drop_piece_in_grid(currGrid, pieces[i], offset)
	# ASSUMPTION $v0 = nextGrid & $v1 = success
	
	subi	$sp, $sp, 4
	sw	$t1, 0($sp)
	sll	$t1, $t1, 4
	add	$t1, $t1, $s4
	
	drop_piece_in_grid($s0, $t1, $t5)
	
	lw	$t1, 0($sp)
	addi	$sp, $sp, 4
	
	bnez	$v1, loop_back_to_offset	# if success:
	li	$t0, 1
	sb	$t0, 0($s5)	# chosen_copy[i] = True	
	
	move	$a0, $v0
	move	$a1, $s5
	move	$a2, $s4
	#jal	backtrack		# backtrack(nextGrid, chosen_copy, pieces)
	move	$t6, $v0	
	bnez	$t6, return_true
	
	li	$t0, 0
	sb	$t0, 0($s5)	# chosen_copy[i] = False
	
loop_back_to_offset:
	addi	$t5, $t5, 1	# offset++
	j	loop_offset
	
loop_back_to_i:
	addi	$t1, $t1, 1	# i++
	addi	$s3, $s3, 1	# chosen+++
	addi	$s5, $s5, 1	# chosen_copy+++
	j	loop_i